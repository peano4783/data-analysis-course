\documentclass[landscape]{slides}
\usepackage[landscape]{geometry}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{color}
\begin{document}

\begin{normalsize}


\begin{slide}
\begin{center}
Анализ потоков данных (Часть 1)

Mining Data Streams (Part 1)

\url{http://mmds.org}

Mining of Massive Datasets

Jure Leskovec, Anand Rajaraman, Jeff Ullman
\end{center}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Потоки данных}}


\begin{itemize}
\item Во многих ситуациях анализа данных весь набор данных заранее неизвестен

\item Управление потоками становится важным, когда the input rate контролируется извне:

  \begin{itemize}
  \item Запросы Google

  \item Обновление статусов в Twitter или Facebook
  \end{itemize}

\item Можно считать, что поток данных бесконечен и нестационарен (распределение изменяется с течением времени)
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Модель потока данных}}


\begin{itemize}
\item Входные элементы поступают с высокой интенсивностью по одному или более входному порту (т.е., потоки)

  \begin{itemize}
  \item Будем называть элементы потока кортежами (tuples)
  \end{itemize}

\item Система не может хранить целый поток так, чтобы к нему был доступ

\item Q: Как выполнять вычисления о потоке используя только ограниченные объем (вторичной) памяти?
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{SGD – поточный алгоритм}}

\begin{itemize}
\item Стохастический градиентный спуск (SGD) – пример поточного алгоритма

\item В машинном обучении: Online Learning

  \begin{itemize}
  \item Позволяет моделировать задачи с непрерывным потоком данных 

  \item Нужен алгоритм для обучения из потока и медленной адаптации к изменениям в данных
  \end{itemize}

\item Идея: Медленные обновления модели

  \begin{itemize}
  \item SGD (SVM, Perceptron) производят малые обновления

  \item Сначала: Обучить классификатор на обучающих данных. 

  \item Затем: По каждому элементу потока немного обновляем модель (используя малую интенсивность обучения)
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Задачи для потоков}}

\begin{itemize}
\item Типы запросов по потоку:

  \begin{itemize}
  \item Выборка данных из потока

    \begin{itemize}
    \item Построение случайной выборки
    \end{itemize}

  \item Запросы по скользящим окнам

    \begin{itemize}
    \item Количество элементов типа x среди последних k элементов потока
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Задачи для потоков}}

\begin{itemize}
\item Типы запросов по потоку:

  \begin{itemize}
  \item Фильтрация потока данных

    \begin{itemize}
    \item Выбор элементов со свойством x из потока
    \end{itemize}

  \item Подсчет различных элементов

    \begin{itemize}
    \item Количество различных элементов среди последних $k$ элементов потока
    \end{itemize}

  \item Оценка моментов

    \begin{itemize}
    \item Оценка среднего/стандартного отклонения последних $k$ элементов потока
    \end{itemize}

  \item Нахождение частых элементов
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Приложения (1)}}

\begin{itemize}
\item Анализ потоков запросов

  \begin{itemize}
  \item Google хочет знать, какие запросы более частые сегодня по сравнению со вчера
  \end{itemize}

\item Анализ потоков кликов

  \begin{itemize}
  \item Yahoo хочет знать, какие из ее страниц получают необучный набор хитов за последний час
  \end{itemize}

\item Анализ новостных лент социальных сетей

  \begin{itemize}
  \item Например, поиск trending-тем в Twitter, Facebook
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Приложения (2)}}


\begin{itemize}
\item Сенсорные сети

  \begin{itemize}
  \item Множество сенсоров (датчиков), посылающих данные центральному контроллеру
  \end{itemize}

\item Записи телефонных звонков

  \begin{itemize}
  \item Data feeds into customer bills as well as settlements between telephone companies
  \end{itemize}

\item IP-пакеты в маршрутизаторе
  
  \begin{itemize}
  \item Сбор информации для оптимальной маршрутизации

  \item Определение DDoS-атак
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
Выборка из потока данных:

Выборка фиксированной пропорции

Выборка растет вместе с ростом потока
\end{slide}


\begin{slide}
\begin{itemize}
\item Будем сохранять выборку

\item Две различные задачи:

  \begin{itemize}
  \item (1) Произвести выборку фиксированной пропорции элементов в потоке (например, 1 из 10)

  \item (2) Хранить случайную выборку фиксированного объема из потенциально бесконечного потока

    \begin{itemize}
    \item В любой <<момент времени>> $k$ требуется иметь случайную выборку из $s$ элементов

    \item Какое свойство выборки следует сохранять?

      \begin{itemize}
      \item Для всех шагов времени $k$ каждый из $k$ встреченных элементов имеет одну и ту же вероятность попадания в выборку
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Выборка фиксированной пропорции}}

\begin{itemize}
\item Задача 1: Выборка фиксированной пропорции

\item Сценарий: Поток запросов поисковой машины

  \begin{itemize}
  \item Поток кортежей: (пользователь, запрос, время)

  \item Ответить на вопрос типа: Как часто пользователь отправлял один и тот же запрос в течение одного дня

  \item Имеется место для хранения $1/10$-й потока запросов
  \end{itemize}

\item Наивное решение:

  \begin{itemize}
  \item Сгенерировать случайное целое число в диапазоне $[0..9]$ для каждого запроса

  \item Сохранить запрос, если это число равно $0$, в противном случае -- не сохранять
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Что не так с наивным подходом}}

\begin{itemize}
\item Простой вопрос: Какую долю запросов среднего пользователя поисковой машины составляют дублирующиеся запросы?

  \begin{itemize}
  \item Пусть каждый пользователь отправляет $x$ запросов единожды и $d$ запросов дважды (всего $x+2d$ запросов)

    \begin{itemize}
    \item Правильный ответ: $d/(x+d)$
    \end{itemize}

  \item Предложенное решение: Сохраняем 10\% запросов

    \begin{itemize}
    \item В выборке будет содержаться $x/10$ недублирующихся запросов и $2d/10$ дублирующихся не менее одного раза

    \item Но только $d/100$ пар дублирующихся
      $$d/100 = 1/10 \cdot 1/10 \cdot d $$

    \item Из $d$ <<дублирующихся>> $18d/100$ встречаются ровно один раз
      $$18d/100 = ((1/10 \cdot 9/10)+(9/10 \cdot 1/10)) \cdot d $$
    \end{itemize}
  \end{itemize}

\item Таким образом, ответ, основанный на выборке, -- это
$$\frac{\frac{d}{100}}{\frac{x}{100} + \frac{d}{100} + \frac{18d}{100}} = \frac{d}{10x+19d} $$
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Решение: Формировать выборку из пользователей}}


Решение:

Выберем $1/10$-ю пользователей и включим все их запросы в выборку

Используем хеш-функцию, хеширующую идентификатор пользователя равномерно по 10 урнам
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Обобщенное решение}}

\begin{itemize}
\item Поток кортежей с ключами:

  \begin{itemize}
  \item Ключ -- некоторое подмножество каждой компоненты кортежа; например, кортеж -- (пользователь, поисковый запрос, время); ключ -- пользователь

  \item Выбор ключа зависит от решаемой задачи
  \end{itemize}

\item Для получения выборки, составляющей $a/b$ долю потока:

  \begin{itemize}
  \item Хешировать ключ каждого кортежа равномерно в $b$ урн

  \item Включить кортеж в выборку, если его хэш-значение не превосходит $a$
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
Выборка из потока данных:

Формирование выборки фиксированного объема

Объем выборки не изменяется с ростом потока
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Сохранение фиксированного объема выборки}}

\begin{itemize}
\item Задача 2: Выборка фиксированного объема

\item Пусть требуется сохранять случайную выборку $S$ размера в точности $s$

  \begin{itemize}
  \item Т.е., ограничение на объем оперативной памяти
  \end{itemize}

\item Почему? Длина потока неизвестна наперед

\item Пусть в момент времени $n$ было просмотрено $n$ элементов

  \begin{itemize}
  \item Каждый элемент содержится в выборке $S$ с одинаковой вероятностью $s/n$
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Решение: выборка фиксированного объема}}

\begin{itemize}
\item Алгоритм (Reservoir Sampling)

  \begin{itemize}
  \item Все первые $s$ элементов потока записать в $S$

  \item Пусть пройдено $n-1$ элементов и теперь пришел $n$-й элемент ($n>s$)

    \begin{itemize}
    \item С вероятностью $s/n$ сохранить $n$-й элемент в выборку, иначе не сохранять

    \item Если $n$-й элемент выбран для сохранения в выборку, то он заменяет один из $s$ элементов в выборке $S$, равномерно выбранный случайным образом
    \end{itemize}
  \end{itemize}

\item Утверждение: Этот алгоритм сохранятет выборку $S$ с требуемым свойством:

  \begin{itemize}
  \item После $n$ элементов выборка содержит каждый пройденный элемент с вероятностью $s/n$
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Доказательство: по индукции}}

\begin{itemize}
\item Докажем это утверждение по индукции:

  \begin{itemize}
  \item Пусть после просмотра $n$ элементов выборка содержит каждый пройденный элемент с вероятностью $s/n$

  \item Требуется показать, что после прохождения элемента $n+1$ выборка сохранит это свойсто

    \begin{itemize}
    \item Выборка содержит каждый пройденный элемент с вероятностью $s/(n+1)$
    \end{itemize}
  \end{itemize}

\item Основание индукции:

  \begin{itemize}
  \item После того, как пройдено $n=s$, элементов выборка $S$ обладает требуемым свойством

    \begin{itemize}
    \item Каждый из $n=s$ элементов содержится в выборке с вероятностью $s/s = 1$
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Доказательство: по индукции}}

Предположение индукции: После $n$ элементов выборка $S$ содержит каждый пройденный элемент с вероятностью $s/n$

Теперь поступает элемент $n+1$

Шаг индукции: Для элементов, которые уже включены в $S$, вероятность их сохранения в $S$:

$$
\left(1 - \frac{s}{n+1}\right) +
\left(\frac{s}{n+1}\right)
\left(\frac{s-1}{s}\right) =
\frac{n}{n+1}
$$


Таким образом, в момент времени $n$, кортежи в $S$ были там с вероятностью $s/n$
В момент времени $n \to n+1$ кортеж был в $S$ с вероятностью $n/(n+1)$
Вероятность того, что кортеж будет включен в $S$ в момент времени $n+1$
$$ = \frac sn \cdot \frac n{n+1} = \frac s{n+1} $$
\end{slide}


\begin{slide}
Запросы по

(длинному) скользящему окну

(sliding window)
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Скользящие окна}}


\begin{itemize}
\item Полезная модель обрабоки потоков -- вопросы касаются окна длины $N$ -- $N$ элементов, поступивших последними.

\item Интересный слуай: $N$ настолько велико, что данные не могут храниться в памяти или даже на диске

  \begin{itemize}
  \item Или у нас так много потоков, что окна для всех хранить невозможно
  \end{itemize}

\item Пример Amazon: 

  \begin{itemize}
  \item Для каждого продукта $X$ сохраняем поток из нулей и единиц, показывающий, был ли продукт продан в момент $n$-й транзакции

  \item Требуется отвечать на запрос, сколько раз продукт $X$ был продан среди последних $k$ продаж
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Скользящие окна: 1 поток}}

Скользящие окна по одному потоку: $N=6$

\begin{verbatim}
q w e r t y u i o p|a s d f g h|j k l z x c v b n m
q w e r t y u i o p a|s d f g h j|k l z x c v b n m
q w e r t y u i o p a s|d f g h j k|l z x c v b n m
q w e r t y u i o p a s d|f g h j k l|z x c v b n m

<-- Прошлое                             Будущее -->
\end{verbatim}

\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Подсчет битов (1)}}

\begin{itemize}
\item Задача: 

  \begin{itemize}
  \item Дан поток нулей и единиц

  \item Быть готовым ответить на запросы типа: Сколько единиц содержится в последних $k$ битах? где $k \leq N$
  \end{itemize}

\item Очевидное решение: 

  \begin{itemize}
  \item Хранить последние $N$ бит

  \item При поступлении нового бита удалять $N+1$-й бит
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Подсчет битов (2)}}

\begin{itemize}
\item Невозможно получить точный ответ, не храня целое окно

\item Проблема: 
Что, если у нас нет возможности хранить $N$ бит?

  \begin{itemize}
  \item Например, обрабатывается 1 миллиард потоков и $N = 1$ миллиарду
  \end{itemize}

\item Но нас удовлетворит и приближенный ответ
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Попытка: простое решение}}

\begin{itemize}
\item Q: Сколько единиц содержится в последних $N$ битах?

\item Простое решение, которое на самом деле не решение: гипотеза равномерности

\item Организуем 2 счетчика
 
  \begin{itemize}
  \item $S$: число единиц с начала потока

  \item $Z$: число нулей с начала потока
  \end{itemize}

\item Сколько единиц содержится в последних $N$ битах? $N \cdot \frac{S}{S+Z}$

\item Но что, если поток неравномерный?

  \begin{itemize}
  \item Что, если распределение изменяется с течением времени?
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Метод DGIM}}


\begin{itemize}
\item Метод DGIM {\em не} предполагает равномерности

\item Хранится $O(\log^2 N)$ бит на поток

\item Метод дает приближенный ответ с погрешностью не более, чем 50\%

  \begin{itemize}
  \item Погрешность может быть уменьшена до любой доли $>0$, если использовать более сложный алгоритм с пропорционально большим количеством бит
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Идея: экспоненциальные окна}}


\begin{itemize}
\item Решение, которое не работает (как надо):

  \begin{itemize}
  \item Подытоживать экспоненциально увеличивающиеся регионы потока, если смотреть назад

  \item Удалять малые регионы, если они начинаются в той же точке, что и б\'oльший регион
  \end{itemize}
\end{itemize}

Окно длины 16 содержит 6 единиц.

Можем восстановить счетчик последних $N$ бит, за исключением того, что мы не знаем, какое количество последних 6 бит содержится в $N$
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Что хорошо}}


\begin{itemize}
\item Хранится только $O(\log^2 N)$ бит

  \begin{itemize}
  \item $O(\log N)$ счетчиков по $\log_2 N$  бит на каждый
  \end{itemize}

\item Простое обновление при поступлении новых битов

\item Погрешность в подсчете не превосходит число единиц в <<неизвестной>> области
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Что не так}}


\begin{itemize}
\item Если единицы распределены относительно равномерно, то погрешность из-за неизвестного региона остается малой -- не более 50\%

\item Но может случиться, что все единицы находятся в неизвестной области в конце

\item В таком случае погрешность неограничена!
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Поправка: метод DGIM}}


\begin{itemize}
\item Идея: Вместо подытоживания блоков фиксированной длины подытоживать блоки с определенным числом единиц:

  \begin{itemize}
  \item Пусть размеры блоков (число единиц) увеличиваются экспоненциально
  \end{itemize}

\item Когда количество единиц в окне невелико, размер блоков остается малым, поэтому погрешности малы
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{DGIM: Временные отметки (Timestamps)}}

\begin{itemize}
\item Каждый бит в потоке имеет временную отметку, начиная с $1, 2,\ldots$

\item Записываем временные отметки по модулю $N$ (размер окна),
поэтому можем представить любую нужную временную отметку с помощью
$O(\log_2 N)$ бит
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{DGIM: Урны}}

\begin{itemize}
\item Урна в методе DGIM -- это запись, состоящая из:

  \begin{itemize}
  \item (A) Временной отметки ее конца [$O(\log N)$ бит]

  \item (B) Числа единиц между ее началом и концом [$O(\log \log N)$ бит]
  \end{itemize}

\item Ограничение на урны: 
Число единиц должно быть степенью числа 2

  \begin{itemize}
  \item Это объясняет $O(\log \log N)$  в (B) выше
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Представление потока в виде урн}}

\begin{itemize}
\item Либо одна, либо две урны с одинаковым количеством единиц, являющимся степенью числа 2

\item Урны не накладываются в смысле временных отметок

\item Урны отсортированы по размеру

  \begin{itemize}
  \item Более ранние урны не меньше, чем более поздние
  \end{itemize}

\item Урны исчезают, когда их конечное время $>N$
временных единиц в прошлое
\end{itemize}

\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Обновление урн (1)}}

\begin{itemize}
\item При поступлении нового бита удалить последнюю (самую давнюю) урну, если ее конечное время на $N$ временных единиц раньше, чем настоящий момент

\item 2 случая: текущий бит равен 0 или 1

\item Если текущий бит равен 0: \\
не производить никаких других изменений
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Обновление урн (2)}}


\begin{itemize}
\item Если текущий бит равен 1:

  \begin{itemize}
  \item (1) Создать новую урну размера 1, в которой содержится только этот бит;\\
    Конечная временная отметка = текущее время

  \item (2) Если теперь имеется три урны размера 1, скомпоновать две самых давних урны в одну урну размера 2

  \item (3) Если теперь имеется три урны размера 2, скомпоновать две самых давних урны в урну размера 4

  \item (4) И так далее...
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Как формировать запрос?}}


\begin{itemize}
\item Для оценки числа единиц в последних $N$ битах:

  \begin{enumerate}
  \item Суммировать размеры всех урн, кроме последней

  \item Добавить половину размера последней урны
  \end{enumerate}

\item Замечание: Нам неизвестно, сколько единиц из последней урны содержится в нашем окне
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Граница погрешности: доказательство}}

\begin{itemize}
\item Почему погрешность составляет 50\%? Давайте докажем!

\item Пусть размер последней урны равен $2^r$

\item Тогда, положив $2^{r-1}$  (т.е., половина) ее единиц
все еще содержится в окне, получаем, что погрешность не превосходит $2^{r-1}$

\item Так как имеется по меньшей мере по одной урне каждого размера, меньшего $2^r$, истинная сумма составляет не менее 

$$ 1 + 2 + 4 + \ldots + 2^{r-1}  = 2^r-1 $$

\item Таким образом, погрешность не превосходит 50\%
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Дальнейшее уменьшение погрешности}}

\begin{itemize}
\item Вместо хранения 1 или 2 урн каждого размера, допускаем $r-1$ или $r$ урн  ($r > 2$)

  \begin{itemize}
  \item За исключением урны наибольшего размера, таковых у нас может быть любое количество между $1$ и $r$ 
  \end{itemize}

\item Погрешность не превосходит $O(1/r)$

\item Правильным подбором $r$ можно балансировать между количеством хранимых бит и погрешностью
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Обобщения}}


\begin{itemize}
\item Можно ли использовать тот же прием для ответа на запросы: Сколько единиц содержится в последних $k$, где $k<N$?

  \begin{itemize}
  \item A: Найти самую раннюю урну $B$, которая пересекается с $k$. Число единиц равно сумме размеров более поздних
  урн $+\frac 12$ размера $B$
  \end{itemize}

\item Можно ли обработать случай, когда поток состоит не из битов, а из целых чисел и требуется получить сумму последних $k$ элементов?
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Обобщения}}

\begin{itemize}
\item Поток положительных целых чисел

\item Требуется вычислить сумму последних $k$ элементов
 
  \begin{itemize}
  \item Amazon: средняя цена последних $k$ продаж
  \end{itemize}

\item Решение

  \begin{itemize}
  \item (1) Если известно, что во всех не более $m$ бит

    \begin{itemize}
    \item Рассматриваем $m$ бит каждого целого числа как отдельный поток

    \item С помощью DGIM подсчитываем количество единиц в каждом целом числе

    \item Сумма равна $=\sum_{i=0}^{m-1} c_i 2^i$\\
$c_i$ -- оценка количества для $i$-го бита

    \end{itemize}

  \item (2) Храним частичные суммы в урнах

    \begin{itemize}
    \item Сумма элементов в урне размера $b$ не превосходит $2^b$\\

Идея: Сумма в каждой урне не превосходит $2^b$ (кроме случая, когда в урне только одно целое число)
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\textbf{\textcolor{blue}{Резюме}}

\begin{itemize}
\item Выборка фиксированной пропорции из потока
  \begin{itemize}
  \item Объем выборки растет вместе с ростом потока
  \end{itemize}

\item Выборка фиксированного объема

  \begin{itemize}
  \item Reservoir sampling

  \item Подсчет количества единиц в последних $N$ элементах

  \begin{itemize}
  \item Экспоненциально уменьшающиеся окна

  \item Обобщения:

    \begin{itemize}
    \item Число единиц в любых последних $k$ $(k < N)$ элементах

    \item Суммы целых чисел в последних $N$ элементах
    \end{itemize}
  \end{itemize}
  \end{itemize}
\end{itemize}

\end{slide}


\end{normalsize}


\end{document}